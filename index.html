<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Noob to Viral - Ultimate Edition</title>
    <style>
        :root {
            --bg: #0b0e14;
            --card: #161b22;
            --cyan: #00f2ff;
            --pink: #ff00ea;
            --green: #39ff14;
            --yellow: #fff200;
            --red: #ff3131;
            --text: #e6edf3;
            --font: 'Outfit', 'Inter', 'Segoe UI', sans-serif;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background-color: var(--bg);
            color: var(--text);
            font-family: var(--font);
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            user-select: none;
        }

        #game-boundary {
            width: 100%;
            max-width: 500px;
            height: 100vh;
            max-height: 850px;
            background: var(--card);
            position: relative;
            display: flex;
            flex-direction: column;
            border: 2px solid #30363d;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.8);
        }

        .screen {
            display: none;
            flex-direction: column;
            height: 100%;
            padding: 24px;
            overflow-y: auto;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            animation: slideIn 0.3s ease-out;
        }

        .screen.active {
            display: flex;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: scale(0.95);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        h1 {
            font-size: 2rem;
            text-align: center;
            color: var(--cyan);
            text-shadow: 0 0 10px var(--cyan);
            margin-bottom: 10px;
        }

        h2 {
            font-size: 1.4rem;
            text-align: center;
            margin-bottom: 15px;
        }

        .btn {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--cyan);
            color: var(--cyan);
            padding: 16px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            margin: 8px 0;
            transition: all 0.2s;
            font-size: 0.9rem;
            text-transform: uppercase;
            width: 100%;
            text-align: center;
        }

        .btn:hover {
            background: var(--cyan);
            color: #000;
            box-shadow: 0 0 15px var(--cyan);
        }

        .btn-mindset {
            border: 2px solid #30363d;
            color: var(--text);
            background: rgba(255, 255, 255, 0.02);
            font-weight: 500;
            letter-spacing: 0.5px;
        }

        .btn-mindset:hover {
            border-color: var(--cyan);
            background: rgba(0, 242, 255, 0.1);
            color: var(--cyan);
            box-shadow: 0 0 10px rgba(0, 242, 255, 0.2);
        }

        .btn-green {
            border-color: var(--green);
            color: var(--green);
        }

        .btn-green:hover {
            background: var(--green);
            color: #000;
        }

        .btn-pink {
            border-color: var(--pink);
            color: var(--pink);
        }

        .btn-pink:hover {
            background: var(--pink);
            color: #fff;
        }

        .game-input {
            width: 100%;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--cyan);
            border-radius: 8px;
            color: #fff;
            font-size: 1rem;
            margin-bottom: 20px;
            text-align: center;
        }

        .progress-bar-container {
            background: #21262d;
            height: 12px;
            border-radius: 6px;
            margin: 10px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            width: 10%;
            background: var(--cyan);
            transition: width 0.4s ease;
        }

        .minigame-layer {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
            width: 100%;
        }

        #canvas-game {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        /* 3x3 Grid for Memory */
        .memory-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            width: 100%;
            max-width: 350px;
            aspect-ratio: 1;
            margin: 0 auto;
        }

        .mem-card {
            background: #30363d;
            border-radius: 6px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2rem;
            cursor: pointer;
            transition: transform 0.1s;
            position: relative;
            overflow: hidden;
        }

        .mem-card:active {
            transform: scale(0.95);
        }

        .history-container {
            margin-top: 15px;
            max-height: 150px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.2);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #333;
            text-align: left;
            font-size: 0.8rem;
        }

        .history-item {
            margin-bottom: 5px;
            padding-bottom: 5px;
            border-bottom: 1px solid #222;
        }

        .badge-growth {
            color: var(--green);
            font-weight: bold;
        }

        .badge-fixed {
            color: var(--pink);
            font-weight: bold;
        }

        .badge-win {
            color: var(--yellow);
            margin-left: 5px;
        }

        .badge-loss {
            color: #888;
            margin-left: 5px;
        }

        .label-small {
            font-size: 0.8rem;
            text-transform: uppercase;
            color: #8b949e;
            margin-bottom: 4px;
        }

        .sort-item {
            padding: 15px;
            background: #30363d;
            border: 1px solid #444;
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            font-weight: bold;
            margin-bottom: 5px;
            width: 100%;
        }

        .sort-item.correct {
            border-color: var(--green);
            background: rgba(0, 255, 0, 0.1);
        }

        #mg-instr-box {
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid var(--green);
            color: #ccffcc;
            padding: 15px;
            border-radius: 8px;
            font-size: 0.95rem;
            margin-bottom: 20px;
            text-align: left;
        }

        .goal-text {
            display: block;
            margin-top: 10px;
            font-weight: bold;
            color: var(--yellow);
            text-align: center;
        }

        @keyframes shake {

            0%,
            100% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(-5px);
            }

            75% {
                transform: translateX(5px);
            }
        }

        .shake {
            animation: shake 0.2s ease-in-out 0s 2;
            border-color: var(--red) !important;
        }
    </style>
</head>

<body>

    <div id="game-boundary">
        <!-- START -->
        <div id="screen-start" class="screen active">
            <h1>NOOB TO <span style="color:var(--pink)">VIRAL</span></h1>
            <p style="text-align:center; margin: 15px 0;">Entrena tu cerebro.<br>Acci√≥n > Reacci√≥n.</p>
            <div id="intro-explanation"
                style="background: rgba(0, 242, 255, 0.05); border: 1px solid rgba(0, 242, 255, 0.2); padding: 15px; border-radius: 8px; margin-bottom: 20px; font-size: 0.85rem; line-height: 1.4; color: #8b949e;">
                <p><strong>¬øEn qu√© consiste?</strong> Es un simulador de mentalidad. Enfrenta desaf√≠os, elige actuar y
                    supera minijuegos para mejorar.</p>
                <p style="margin-top: 8px;"><strong>¬øEl objetivo?</strong> Desarrollar tu <em>Growth Mindset</em>. Lleva
                    tu Skill al 100% y pasa de Noob a Viral.</p>
            </div>
            <div style="flex-grow:1; display:flex; flex-direction:column; justify-content:center;">
                <label class="label-small">TU NOMBRE:</label>
                <input type="text" id="player-name-in" class="game-input" placeholder="Ingresa tu nombre..."
                    maxlength="20">
                <p class="label-small">ELIGE TU CAMINO:</p>
                <button class="btn" onclick="preStart('gaming')">üéÆ PRO GAMER</button>
                <button class="btn btn-pink" style="border-color:var(--pink);" onclick="preStart('social')">üì± CONTENT
                    CREATOR</button>
            </div>
        </div>

        <!-- SCENARIO -->
        <div id="screen-scenario" class="screen">
            <div id="top-stats">
                <p class="label-small" id="path-label">CAMINO: GAMING</p>
                <div class="progress-bar-container">
                    <div id="main-progress" class="progress-fill"></div>
                </div>
                <p style="text-align:right; font-size:0.8rem;" id="round-counter">NIVEL 1/10</p>
            </div>
            <div style="flex-grow:1; display:flex; flex-direction:column; justify-content:center; gap: 10px;"
                id="choice-container"></div>
        </div>

        <!-- MINIGAME INTRO -->
        <div id="screen-mg-intro" class="screen" style="justify-content:center; text-align:center;">
            <h2 id="mg-name" style="color:var(--green)">ENTRENANDO...</h2>
            <div id="mg-instr-box">
                <span id="mg-desc"></span>
                <span id="mg-goal" class="goal-text"></span>
            </div>
            <button class="btn btn-green" onclick="startActiveMinigame()">¬°ACEPTO EL RETO!</button>
        </div>

        <!-- MINIGAME ACTIVE -->
        <div id="screen-mg-play" class="screen" style="padding:0;">
            <div id="mg-header"
                style="padding: 15px; display:flex; justify-content:space-between; align-items:center; background: rgba(0,0,0,0.3); z-index:10;">
                <div id="mg-timer" style="font-size:1.5rem; font-weight:bold; color:var(--yellow)"></div>
                <div id="mg-subtext" style="font-size:0.9rem;"></div>
            </div>
            <div class="minigame-layer" id="mg-container">
                <canvas id="canvas-game"></canvas>
                <div id="dom-game-wrap" style="width:100%; padding:20px; display:none;"></div>
            </div>
        </div>

        <!-- ROUND RESULT -->
        <div id="screen-result" class="screen" style="justify-content:center; text-align:center;">
            <h1 id="res-status"></h1>
            <div id="res-icon" style="font-size:5rem; margin:20px 0;"></div>
            <p id="res-feedback" style="margin-bottom:30px; line-height:1.6;"></p>
            <button class="btn" onclick="goToNextLevel()">CONTINUAR</button>
        </div>

        <!-- FINAL RESULT -->
        <div id="screen-final" class="screen" style="text-align:center;">
            <h1 id="final-name-title">¬°AN√ÅLISIS COMPLETO!</h1>
            <div id="final-stats"
                style="margin: 10px 0; padding:15px; border:2px solid var(--cyan); border-radius:10px;">
                <p>Nivel de Mentalidad</p>
                <div style="font-size:2.5rem; font-weight:bold; color:var(--green);" id="final-val">0%</div>
                <p id="final-profile" style="color:var(--yellow); font-weight:bold; margin-top:5px; font-size:1.1rem;">
                </p>
            </div>

            <div
                style="background:rgba(255,255,255,0.05); padding:10px; border-radius:8px; font-size:0.8rem; text-align:left; border-left: 4px solid var(--cyan); margin-bottom:15px;">
                <p id="final-analysis-text"></p>
            </div>

            <div class="history-container" id="history-log"></div>

            <a href="https://www.ted.com/talks/carol_dweck_the_power_of_believing_that_you_can_improve?language=es"
                target="_blank" class="btn btn-green"
                style="text-decoration:none; display:inline-block; margin-bottom:10px;">
                üß† VER CHARLA TED: EL PODER DEL "TODAV√çA"
            </a>
            <br>
            <button class="btn" style="font-size:0.8rem; border-color:#444; color:#888;"
                onclick="location.reload()">REINICIAR SIMULACI√ìN</button>
        </div>
    </div>

    <script src="situations.js"></script>
    <script>
        const paths = {
            gaming: {
                name: "Pro Gamer", scenarios: [], icons: ['üéÆ', 'üñ±Ô∏è', '‚å®Ô∏è', 'üéß', 'üèÜ', 'üëæ', 'üïπÔ∏è', 'üîã']
            },
            social: {
                name: "Content Creator", scenarios: [], icons: ['üì±', 'üì∏', '‚ú®', '‚ù§Ô∏è', 'üî•', 'üé¨', 'üé§', 'üíé']
            }
        };

        let state = { name: "", path: null, level: 0, skill: 10, history: [], mgPerformance: [] };

        function showScreen(key) { document.querySelectorAll('.screen').forEach(s => s.classList.remove('active')); document.getElementById('screen-' + key).classList.add('active'); }

        function preStart(p) {
            const nameInput = document.getElementById('player-name-in');
            const name = nameInput.value.trim();

            if (!name) {
                nameInput.classList.remove('shake');
                void nameInput.offsetWidth; // Trigger reflow
                nameInput.classList.add('shake');
                nameInput.placeholder = "¬°EL NOMBRE ES OBLIGATORIO!";
                return;
            }

            state.name = name;
            state.path = p;

            // Randomly select 10 from all available scenarios in situations.js
            let allScenarios = [...gameData[p]];
            allScenarios.sort(() => Math.random() - 0.5);
            paths[p].scenarios = allScenarios.slice(0, 10);

            // Prepare unique minigames for this session
            activeMinigames = [...minigames].sort(() => Math.random() - 0.5);

            state.level = 0; state.skill = 10; state.history = []; state.mgPerformance = [];
            loadScenario();
        }

        function loadScenario() {
            if (state.level >= 10) { showFinal(); return; }
            const data = paths[state.path].scenarios[state.level];
            const container = document.getElementById('choice-container');
            container.innerHTML = '';
            const t = document.createElement('h2'); t.id = "scen-title"; t.innerText = data.t; t.style.color = "var(--yellow)";
            const d = document.createElement('p'); d.id = "scen-desc"; d.innerText = data.d; d.style.marginBottom = "20px"; d.style.textAlign = "center"; d.style.lineHeight = "1.5";
            container.appendChild(t); container.appendChild(d);

            const bFixed = document.createElement('button'); bFixed.className = 'btn btn-mindset'; bFixed.innerText = data.f; bFixed.onclick = () => handleChoice(false);
            const bGrowth = document.createElement('button'); bGrowth.className = 'btn btn-mindset'; bGrowth.innerText = data.g; bGrowth.onclick = () => handleChoice(true);

            if (Math.random() > 0.5) { container.appendChild(bFixed); container.appendChild(bGrowth); }
            else { container.appendChild(bGrowth); container.appendChild(bFixed); }

            document.getElementById('path-label').innerText = `CAMINO: ${state.path.toUpperCase()}`;
            document.getElementById('round-counter').innerText = `NIVEL ${state.level + 1}/10`;
            document.getElementById('main-progress').style.width = state.skill + '%';
            showScreen('scenario');
        }

        function handleChoice(isGrowth) {
            // Will update history with MG result later
            if (isGrowth) prepareMinigame();
            else {
                state.history.push({ title: paths[state.path].scenarios[state.level].t, choice: 'REACCI√ìN', mgResult: '-' });
                state.skill -= 5; if (state.skill < 0) state.skill = 0; showRoundResult(false, 0, false);
            }
        }

        const minigames = [
            { id: 'clicker', name: 'Reflejos R√°pidos', desc: '¬°Atento! Los iconos aparecen y desaparecen m√°s lento. Suma 10 puntos. ¬°CUIDADO! Si tocas una BOMBA, pierdes instant√°neamente.', goal: 'Meta: 10 puntos' },
            { id: 'maze', name: 'Laberinto de Precisi√≥n', desc: 'Haz clic en la BOLA VERDE y arr√°strala hasta la meta amarilla sin tocar las paredes rojas. Si tocas la pared, PIERDES.', goal: 'Meta: Llegar al final' },
            { id: 'memory', name: 'Memotest 4x4', desc: 'Encuentra las 8 parejas antes de que se acabe el tiempo (30s).', goal: 'Meta: Todas las parejas' },
            { id: 'word', name: 'Decodificador', desc: 'Descifra la palabra desordenada. Si el tiempo se acaba, pierdes.', goal: 'Meta: Palabra correcta' },
            { id: 'sorter', name: 'Ordenador L√≥gico', desc: 'Ordena de MENOR a MAYOR. Los errores no restan vida, pero pierdes tiempo.', goal: 'Meta: Orden perfecto' },
            { id: 'neuro', name: 'Neuro-Patr√≥n', desc: 'Memoriza la secuencia de emojis. Si fallas, ver√°s la correcci√≥n.', goal: 'Meta: Secuencia perfecta' },
            { id: 'search', name: 'Caza del Intruso', desc: 'Encuentra al emoji intruso que es diferente a los dem√°s lo m√°s r√°pido posible.', goal: 'Meta: Encontrar al diferente' },
            { id: 'math', name: 'C√°lculo R√°pido', desc: 'Resuelve 3 operaciones matem√°ticas simples antes de que se acabe el tiempo.', goal: 'Meta: 3 respuestas correctas' },
            { id: 'reaction', name: 'Reflejo Puro', desc: 'Espera a que la pantalla cambie a VERDE y haz clic lo m√°s r√°pido posible. No te adelantes.', goal: 'Meta: Click en verde' },
            { id: 'collector', name: 'Recolector de Ideas', desc: 'Mueve el recolector para atrapar 10 estrellas fugaces. ¬°Cuidado con los meteoritos rojos!', goal: 'Meta: 10 estrellas' }
        ];

        let activeMinigames = [];

        function prepareMinigame() {
            state.currentMG = activeMinigames[state.level];
            document.getElementById('mg-name').innerText = state.currentMG.name;
            document.getElementById('mg-desc').innerText = state.currentMG.desc;
            document.getElementById('mg-goal').innerText = state.currentMG.goal;
            showScreen('mg-intro');
        }

        let mgInt; let mgAnim; let mScore = 0; let mTimer = 0; let mLives = 3; let currentWord = "";
        let mgTimeouts = []; let mgIntervals = []; let mgActive = false;

        function clearMGStuff() {
            clearInterval(mgInt);
            if (mgAnim) cancelAnimationFrame(mgAnim);
            mgTimeouts.forEach(t => clearTimeout(t));
            mgIntervals.forEach(i => clearInterval(i));
            mgTimeouts = []; mgIntervals = [];
        }

        function startActiveMinigame() {
            showScreen('mg-play'); const c = document.getElementById('canvas-game'); const d = document.getElementById('dom-game-wrap');
            c.style.display = 'none'; d.style.display = 'none';
            clearMGStuff();
            mScore = 0; mTimer = 0; mLives = 3; mgActive = true;
            updateMGHeader();

            switch (state.currentMG.id) {
                case 'clicker': mTimer = 15; initClicker(); break;
                case 'maze': mTimer = 20; initMaze(); break;
                case 'memory': mTimer = 30; initMemory(); break; // 4x4 standard
                case 'word': mTimer = 15; initWord(); break;
                case 'sorter': mTimer = 15; initSorter(); break;
                case 'neuro': mTimer = 25; initNeuro(); break;
                case 'search': mTimer = 10; initSearch(); break;
                case 'math': mTimer = 15; initMath(); break;
                case 'reaction': mTimer = 10; initReaction(); break;
                case 'collector': mTimer = 20; initCollector(); break;
            }
            mgInt = setInterval(() => {
                mTimer--; updateMGHeader();
                if (mTimer <= 0) {
                    if (state.currentMG.id === 'word') {
                        // Show word before fail
                        document.getElementById('winin').value = currentWord;
                        document.getElementById('winin').style.color = "var(--red)";
                        document.getElementById('winin').style.borderColor = "var(--red)";
                        setTimeout(() => endMinigame(false), 2000);
                        clearInterval(mgInt);
                    } else {
                        endMinigame(false);
                    }
                }
            }, 1000);
        }

        function updateMGHeader() {
            let sub = "";
            if (state.currentMG.id === 'clicker') sub = `Aciertos: ${mScore}/10`;
            else if (['maze', 'neuro'].includes(state.currentMG.id)) sub = "Vida: 1";
            else sub = "Tiempo restante"; // Sorter, Word, Memory

            document.getElementById('mg-timer').innerText = mTimer; document.getElementById('mg-subtext').innerText = sub;
        }

        function endMinigame(success, gain = 10) {
            if (!mgActive) return;
            mgActive = false;
            clearMGStuff();
            state.mgPerformance.push(success);
            state.history.push({ title: paths[state.path].scenarios[state.level].t, choice: 'ACCI√ìN', mgResult: success ? 'WIN' : 'LOSS' });

            if (success) {
                state.skill += gain; if (state.skill > 100) state.skill = 100;
                showRoundResult(true, gain, true);
            } else {
                state.skill += 5; if (state.skill > 100) state.skill = 100;
                showRoundResult(true, 5, false);
            }
        }

        function showRoundResult(isGrowth, gain = 0, mgSuccess = false) {
            const h1 = document.getElementById('res-status'); const fb = document.getElementById('res-feedback'); const ico = document.getElementById('res-icon');

            if (isGrowth) {
                if (mgSuccess) {
                    h1.innerText = "¬°RETO SUPERADO!"; ico.innerText = "‚ö°";
                    fb.innerHTML = `Excelente ejecuci√≥n. Tu cerebro ha reforzado una nueva conexi√≥n.<br><br><b>Progreso: +${gain}% Skill</b>`;
                } else {
                    h1.innerText = "¬°INTENTO FALLIDO!"; ico.innerText = "üí™";
                    fb.innerHTML = `No lograste la meta, pero aqu√≠ est√° la clave del Growth Mindset:<br><b>El resultado no te define, el esfuerzo s√≠.</b><br>Aprendiste del error y seguiste adelante.<br><br><b>Progreso: +${gain}% Skill</b>`;
                }
            } else {
                h1.innerText = "REACCI√ìN PASIVA"; ico.innerText = "üö´";
                const quote = gameData.quotes[Math.floor(Math.random() * gameData.quotes.length)];
                fb.innerHTML = `<div style="font-style: italic; margin-bottom: 15px; color: #8b949e;">"${quote.text}"<br><span style="font-size: 0.8rem; font-weight: bold;">‚Äî ${quote.author}</span></div>
                                Te rendiste antes de empezar. El cerebro no aprende si evitas el desaf√≠o.<br><br><b>Penalizaci√≥n: -5% Skill</b>`;
            }
            showScreen('result');
        }

        function goToNextLevel() { state.level++; loadScenario(); }

        function showFinal() {
            const growthCount = state.history.filter(h => h.choice === 'ACCI√ìN').length;
            const mgWins = state.mgPerformance.filter(x => x).length;
            const mgTotal = state.mgPerformance.length;

            let profile = ""; let analysis = "";
            if (growthCount < 4) {
                profile = gameData.profiles.static.title;
                analysis = gameData.profiles.static.analysis;
            } else if (growthCount >= 8) {
                if (mgWins / mgTotal > 0.7) {
                    profile = gameData.profiles.master.title;
                    analysis = gameData.profiles.master.analysis;
                } else {
                    profile = gameData.profiles.warrior.title;
                    analysis = gameData.profiles.warrior.analysis;
                }
            } else {
                profile = gameData.profiles.transition.title;
                analysis = gameData.profiles.transition.analysis;
            }

            document.getElementById('final-name-title').innerText = `INFORME: ${state.name.toUpperCase()}`;
            document.getElementById('final-val').innerText = state.skill + '%';
            document.getElementById('final-profile').innerText = profile;

            // Add specific feedback about failures (Growth Mindset in action)
            let growthFailures = state.history.filter(h => h.choice === 'ACCI√ìN' && h.mgResult === 'LOSS').length;
            if (growthFailures > 0) {
                analysis += `<br><br><strong>Nota de Crecimiento:</strong> Has fallado en ${growthFailures} desaf√≠os, ¬°y eso es genial! En el Growth Mindset, el fallo no es el final, es solo informaci√≥n. Al atreverte a jugar y perder, has ganado m√°s experiencia que el que nunca lo intent√≥.`;
            }

            document.getElementById('final-analysis-text').innerHTML = analysis;

            const log = document.getElementById('history-log'); log.innerHTML = '<b>Bit√°cora de Decisiones:</b><br>';
            state.history.forEach((h, i) => {
                let mgIcon = "";
                if (h.choice === 'ACCI√ìN') mgIcon = (h.mgResult === 'WIN') ? '<span class="badge-win">‚úÖ</span>' : '<span class="badge-loss">‚ùå</span>';
                log.innerHTML += `<div class="history-item">${i + 1}. ${h.title}: <span class="${h.choice === 'ACCI√ìN' ? 'badge-growth' : 'badge-fixed'}">${h.choice}</span>${mgIcon}</div>`;
            });
            showScreen('final');
        }

        // Download Results function removed per user request

        // --- MINIGAMES V6 ---

        function initClicker() {
            const c = document.getElementById('canvas-game'); c.style.display = 'block'; const ctx = c.getContext('2d');
            c.width = 400; c.height = 500;
            let items = []; let bombIcon = 'üí£'; let goodIcons = paths[state.path].icons;

            function loop() {
                ctx.clearRect(0, 0, c.width, c.height);
                // Spawn Rate: 2.5% chance per frame, max 4 items. Better for mobile.
                if (Math.random() < 0.025 && items.length < 4) {
                    const isBomb = Math.random() < 0.25;
                    items.push({
                        x: Math.random() * 320 + 40, y: Math.random() * 420 + 40,
                        icon: isBomb ? bombIcon : goodIcons[Math.floor(Math.random() * goodIcons.length)],
                        isBomb: isBomb,
                        life: 240, // 4s
                        maxLife: 240,
                        scale: 0
                    });
                }
                for (let i = items.length - 1; i >= 0; i--) {
                    let it = items[i]; it.life--;
                    if (it.life > 220) it.scale = (240 - it.life) / 20;
                    else if (it.life < 20) it.scale = it.life / 20;
                    else it.scale = 1;

                    ctx.save(); ctx.translate(it.x, it.y); ctx.scale(it.scale, it.scale);
                    ctx.font = "45px Arial"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText(it.icon, 0, 0);

                    // Visible Hitbox for Debug (Optional, removed for final)
                    // ctx.strokeStyle="rgba(255,255,255,0.2)"; ctx.beginPath(); ctx.arc(0,0,35,0,Math.PI*2); ctx.stroke();

                    ctx.fillStyle = it.isBomb ? "red" : "lime"; ctx.fillRect(-20, 30, 40 * (it.life / it.maxLife), 4);
                    ctx.restore();

                    if (it.life <= 0) items.splice(i, 1);
                }
                mgAnim = requestAnimationFrame(loop);
            }
            loop();

            const handleHit = (clientX, clientY) => {
                const r = c.getBoundingClientRect();
                const scaleX = c.width / r.width;
                const scaleY = c.height / r.height;
                const mx = (clientX - r.left) * scaleX;
                const my = (clientY - r.top) * scaleY;

                for (let i = items.length - 1; i >= 0; i--) {
                    let it = items[i];
                    if (Math.hypot(mx - it.x, my - it.y) < 45) {
                        if (it.isBomb) {
                            mLives = 0; updateMGHeader(); items.splice(i, 1);
                            c.style.backgroundColor = "rgba(255,0,0,0.3)"; setTimeout(() => c.style.backgroundColor = "transparent", 100);
                            endMinigame(false);
                        } else {
                            mScore++; updateMGHeader(); items.splice(i, 1);
                            if (mScore >= 10) endMinigame(true, 15);
                        }
                        break;
                    }
                }
            };

            c.onmousedown = (e) => handleHit(e.clientX, e.clientY);
            c.ontouchstart = (e) => {
                e.preventDefault();
                handleHit(e.touches[0].clientX, e.touches[0].clientY);
            };
        }

        function initMaze() {
            const c = document.getElementById('canvas-game'); c.style.display = 'block'; const ctx = c.getContext('2d'); c.width = 400; c.height = 500;
            let dragging = false; let ballX = 60, ballY = 60;
            const track2 = [{ x: 30, y: 30, w: 80, h: 100 }, { x: 30, y: 100, w: 50, h: 350 }, { x: 30, y: 400, w: 340, h: 50 }, { x: 320, y: 150, w: 50, h: 300 }, { x: 150, y: 150, w: 220, h: 50 }, { x: 150, y: 150, w: 50, h: 150 }];
            const goal = { x: 175, y: 275 };
            function draw() {
                ctx.fillStyle = "#ff3131"; ctx.fillRect(0, 0, 400, 500);
                ctx.fillStyle = "#00f2ff"; track2.forEach(t => ctx.fillRect(t.x, t.y, t.w, t.h));
                ctx.fillStyle = "#fff"; ctx.beginPath(); ctx.arc(60, 60, 15, 0, 7); ctx.fill();
                ctx.fillStyle = "#fff200"; ctx.beginPath(); ctx.arc(goal.x, goal.y, 20, 0, 7); ctx.fill();
                ctx.fillStyle = "#39ff14"; ctx.beginPath(); ctx.arc(ballX, ballY, 12, 0, 7); ctx.fill();
                mgAnim = requestAnimationFrame(draw);
            }
            draw();

            const getPos = (e) => {
                const r = c.getBoundingClientRect();
                return { x: (e.clientX - r.left) * (c.width / r.width), y: (e.clientY - r.top) * (c.height / r.height) };
            };

            const handleMove = (e) => {
                if (!dragging) return;
                e.preventDefault();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                const p = getPos({ clientX, clientY });
                ballX = p.x; ballY = p.y;
                if (!track2.some(t => p.x > t.x && p.x < t.x + t.w && p.y > t.y && p.y < t.y + t.h)) { dragging = false; ballX = 60; ballY = 60; endMinigame(false); }
                if (Math.hypot(p.x - goal.x, p.y - goal.y) < 20) { dragging = false; endMinigame(true, 15); }
            };

            const handleStart = (e) => {
                e.preventDefault();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                const p = getPos({ clientX, clientY });
                if (Math.hypot(p.x - ballX, p.y - ballY) < 30) dragging = true;
            };

            const handleEnd = () => { dragging = false; if (Math.hypot(ballX - goal.x, ballY - goal.y) > 20) { ballX = 60; ballY = 60; } };

            c.onmousedown = handleStart;
            c.ontouchstart = handleStart;
            window.onmousemove = handleMove;
            window.ontouchmove = handleMove;
            window.onmouseup = handleEnd;
            window.ontouchend = handleEnd;
        }

        function initMemory() {
            const d = document.getElementById('dom-game-wrap'); d.style.display = 'block'; d.innerHTML = '<div class="memory-grid" id="mgrid"></div>';
            const pack = paths[state.path].icons;
            // 8 cards total = 4 pairs.
            let icons4 = pack.slice(0, 4);
            let cards = [...icons4, ...icons4];
            cards.sort(() => Math.random() - 0.5);
            let fli = []; let match = 0;

            cards.forEach(e => {
                const c = document.createElement('div'); c.className = 'mem-card'; c.style.aspectRatio = "1"; c.onclick = () => {
                    if (fli.length < 2 && !c.innerText && !c.classList.contains('solved')) {
                        c.innerText = e; fli.push(c);
                        if (fli.length === 2) {
                            if (fli[0].innerText === fli[1].innerText) {
                                match++; fli[0].classList.add('solved'); fli[1].classList.add('solved'); fli[0].style.borderColor = 'var(--green)'; fli[1].style.borderColor = 'var(--green)';
                                fli = []; if (match === 4) endMinigame(true, 20);
                            } else {
                                setTimeout(() => { fli[0].innerText = ''; fli[1].innerText = ''; fli = []; }, 600);
                            }
                        }
                    }
                }; document.getElementById('mgrid').appendChild(c);
            });
        }

        function initWord() {
            const d = document.getElementById('dom-game-wrap'); d.style.display = 'block';
            const words = ['PODER', 'META', 'IDEAS', 'LOGRO', 'CAMBIO', 'VALOR', 'PREGUNTAR', 'PROCESO', 'MENTE', 'ESFUERZO']; currentWord = words[Math.floor(Math.random() * words.length)];
            // Soft Scramble: Keep first or last char fixed if word is short, or just swap a few
            let scrambled = currentWord.split('');
            if (scrambled.length > 3) {
                // Shuffle but ensure it's not the same word
                for (let i = scrambled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [scrambled[i], scrambled[j]] = [scrambled[j], scrambled[i]];
                }
                if (scrambled.join('') === currentWord) { // Simple fix if it didn't scramble
                    [scrambled[0], scrambled[1]] = [scrambled[1], scrambled[0]];
                }
            } else {
                scrambled.reverse(); // For very short words like 'AUN' (if I added them) or 'META' (4 chars)
            }
            d.innerHTML = `<h3 style="margin-bottom:20px;">ORDENA: <span style="color:var(--cyan); letter-spacing:5px;">${scrambled.join('')}</span></h3><input type="text" id="winin" class="game-input">`;
            const ipt = document.getElementById('winin'); ipt.focus(); ipt.oninput = () => { if (ipt.value.toUpperCase() === currentWord) endMinigame(true, 15); }
        }

        function initSorter() {
            const d = document.getElementById('dom-game-wrap'); d.style.display = 'block';
            let nums = []; for (let i = 0; i < 5; i++) nums.push(Math.floor(Math.random() * 100)); nums.sort((a, b) => a - b);
            d.innerHTML = `<h3>ORDENA DE MENOR A MAYOR:</h3><div id="sort-c"></div>`;
            [...nums].sort(() => Math.random() - 0.5).forEach(n => {
                const it = document.createElement('div'); it.className = 'sort-item'; it.innerText = n; it.onclick = () => {
                    if (n === nums[0]) { it.style.borderColor = 'var(--green)'; nums.shift(); if (!nums.length) endMinigame(true, 15); }
                    else {
                        // Visual feedback only
                        it.style.backgroundColor = 'var(--pink)';
                        setTimeout(() => it.style.backgroundColor = '#30363d', 200);
                    }
                }; document.getElementById('sort-c').appendChild(it);
            });
        }

        function initNeuro() {
            const d = document.getElementById('dom-game-wrap'); d.style.display = 'block';
            const emojis = ['üöÄ', 'üî•', 'üíé', '‚ö°'];
            let seq = []; for (let i = 0; i < 4; i++) seq.push(Math.floor(Math.random() * 4)); let uSeq = [];
            d.innerHTML = `<h3>MEMORIZA LA SECUENCIA:</h3><div id="nbox" style="width:100%;height:100px;border-radius:10px;margin:20px 0;border:2px solid #fff;display:flex;justify-content:center;align-items:center;font-size:3.5rem;"></div><div id="nbtns" style="display:flex;gap:5px;"></div>`;
            let i = 0;
            let iv = setInterval(() => {
                const box = document.getElementById('nbox');
                if (box) {
                    box.innerText = emojis[seq[i]];
                    mgTimeouts.push(setTimeout(() => { if (box) box.innerText = ''; }, 500));
                    i++;
                    if (i >= 4) {
                        clearInterval(iv);
                        mgTimeouts.push(setTimeout(() => enable(), 600)); // Wait before showing buttons
                    }
                }
            }, 1000);
            mgIntervals.push(iv);
            function enable() {
                const ctr = document.getElementById('nbtns'); ctr.innerHTML = '';
                emojis.forEach((em, idx) => {
                    const b = document.createElement('button'); b.className = 'btn'; b.style.flex = "1"; b.style.height = "70px"; b.style.fontSize = "2rem"; b.innerText = em; b.style.touchAction = "none";
                    b.onpointerdown = () => { b.style.background = "rgba(255,255,255,0.2)"; }; b.onpointerup = () => { b.style.background = "transparent"; check(idx); };
                    b.onpointerleave = () => { b.style.background = "transparent"; };
                    ctr.appendChild(b);
                });
            }
            function check(idx) {
                uSeq.push(idx);
                if (idx !== seq[uSeq.length - 1]) {
                    // Fail feedback: Show comparison
                    const box = document.getElementById('nbox');
                    box.style.fontSize = "1.2rem";
                    box.style.flexDirection = "column";
                    box.innerHTML = `<span style="color:var(--red)">Tu: ${uSeq.map(x => emojis[x]).join(' ')}</span>
                                     <span style="color:var(--green)">Era: ${seq.map(x => emojis[x]).join(' ')}</span>`;
                    setTimeout(() => endMinigame(false), 2500);
                } else {
                    if (uSeq.length === 4) endMinigame(true, 20);
                }
            }
        }

        function initSearch() {
            const d = document.getElementById('dom-game-wrap'); d.style.display = 'block';
            d.innerHTML = '<h3>ENCUENTRA EL INTRUSO:</h3><div class="memory-grid" id="sgrid"></div>';

            // Extended Categories for variety (at least 15 each)
            const categories = [
                { name: 'animales', items: ['üê∂', 'üê±', 'üê≠', 'üêπ', 'üê∞', 'ü¶ä', 'üêª', 'üêº', 'üê®', 'üêØ', 'ü¶Å', 'üêÆ', 'üê∑', 'üê∏', 'üêµ', 'üêî', 'üêß', 'üê¶', 'ü¶â'] },
                { name: 'frutas', items: ['üçé', 'üçå', 'üçí', 'üçá', 'üçâ', 'üçç', 'ü•ù', 'üçã', 'üçë', 'üçê', 'üçì', 'ü´ê', 'üçä', 'üçà', 'üçè', 'ü•≠', 'ü••'] },
                { name: 'objetos', items: ['‚öΩ', 'üèÄ', 'ÔøΩ', 'üèê', 'ÔøΩ', 'üèà', '‚öæ', 'ÔøΩ', 'ÔøΩ', 'üèì', 'üé∏', 'üé®', 'üì∑', 'üîç', 'üéß', 'üíª', 'üì±', '‚åö', 'üéÆ'] },
                { name: 'comida', items: ['üçï', 'ÔøΩ', 'ÔøΩ', 'ÔøΩ', 'ÔøΩ', 'üßÇ', 'ü•ì', 'ÔøΩ', 'üßá', 'ÔøΩ', 'ÔøΩ', 'ü•ê', 'ü•®', 'ü•Ø', 'üßÄ', 'ÔøΩ', 'üåØ'] }
            ];

            // Pick 2 different categories
            const shuffled = [...categories].sort(() => Math.random() - 0.5);
            const mainCat = shuffled[0];
            const intruderCat = shuffled[1];

            // Shuffle main category items and take 15 DIFFERENT ones
            let mainItems = [...mainCat.items].sort(() => Math.random() - 0.5).slice(0, 15);

            // Pick 1 random intruder from the other category
            const intruder = intruderCat.items[Math.floor(Math.random() * intruderCat.items.length)];

            // Combine: 15 unique items from main cat + 1 intruder
            let cards = [...mainItems, intruder];
            cards.sort(() => Math.random() - 0.5);

            cards.forEach(e => {
                const c = document.createElement('div'); c.className = 'mem-card'; c.innerText = e;
                c.style.fontSize = "2.2rem";
                c.onclick = () => { if (e === intruder) endMinigame(true, 15); else endMinigame(false); };
                document.getElementById('sgrid').appendChild(c);
            });
        }

        function initMath() {
            const d = document.getElementById('dom-game-wrap'); d.style.display = 'block';
            let count = 0;
            const next = () => {
                count++; if (count > 3) { endMinigame(true, 15); return; }
                let a = Math.floor(Math.random() * 15) + 1; let b = Math.floor(Math.random() * 15) + 1;
                const op = Math.random() > 0.5 ? '+' : '-';
                // Ensure positive result for subtraction
                if (op === '-' && b > a) { [a, b] = [b, a]; }
                const ans = op === '+' ? a + b : a - b;
                d.innerHTML = `<h3>RESOLVER (${count}/3):</h3><div style="font-size:3rem; margin:20px 0;">${a} ${op} ${b} = ?</div><input type="number" id="math-in" class="game-input" pattern="[0-9]*" inputmode="numeric">`;
                const ipt = document.getElementById('math-in'); ipt.focus();
                ipt.oninput = () => { if (parseInt(ipt.value) === ans) next(); };
            };
            next();
        }

        function initReaction() {
            const d = document.getElementById('dom-game-wrap'); d.style.display = 'block';
            d.innerHTML = '<div id="react-box" style="width:100%; height:300px; background:var(--red); border-radius:15px; display:flex; justify-content:center; align-items:center; font-size:1.5rem; font-weight:bold; cursor:pointer;">ESPERA...</div>';
            const box = document.getElementById('react-box');
            let ready = false; let start = 0;
            let delay = 2000 + Math.random() * 3000;
            let tout = setTimeout(() => {
                ready = true; box.style.background = "var(--green)"; box.innerText = "¬°YA! TOCA AQU√ç"; start = Date.now();
                // Auto-fail after 500ms since it became green
                mgTimeouts.push(setTimeout(() => {
                    if (mgActive && ready) {
                        box.style.background = "var(--red)";
                        box.innerText = "¬°MUY LENTO!";
                        mgTimeouts.push(setTimeout(() => endMinigame(false), 500));
                    }
                }, 500));
            }, delay);
            mgTimeouts.push(tout);

            const handle = () => {
                if (!ready) { endMinigame(false); }
                else {
                    const diff = Date.now() - start;
                    if (diff <= 500) endMinigame(true, 20);
                    else endMinigame(false);
                }
            };
            box.onmousedown = (e) => { e.preventDefault(); handle(); };
            box.ontouchstart = (e) => { e.preventDefault(); handle(); };
        }

        function initCollector() {
            const c = document.getElementById('canvas-game'); c.style.display = 'block'; const ctx = c.getContext('2d');
            c.width = 400; c.height = 500;
            let basketX = 170; let items = []; let stars = 0;

            // Instructions
            ctx.fillStyle = "#fff";
            ctx.font = "14px Arial";
            ctx.textAlign = "center";
            ctx.fillText("Mueve el mouse/dedo para mover el recolector", 200, 20);

            function loop() {
                ctx.clearRect(0, 0, c.width, c.height);

                // Instructions
                ctx.fillStyle = "#888";
                ctx.font = "12px Arial";
                ctx.textAlign = "center";
                ctx.fillText("Atrapa ‚≠ê | Evita ‚òÑÔ∏è", 200, 15);

                // Draw Basket
                ctx.fillStyle = "var(--cyan)"; ctx.fillRect(basketX, 450, 60, 20);
                // Spawn - REDUCED from 0.04 to 0.02
                if (Math.random() < 0.025) {
                    const isBad = Math.random() < 0.25; // Back to 25%
                    items.push({ x: Math.random() * 370, y: -20, isBad, icon: isBad ? '‚òÑÔ∏è' : '‚≠ê', speed: 2 + Math.random() * 2 }); // Reduced speed
                }
                for (let i = items.length - 1; i >= 0; i--) {
                    let it = items[i]; it.y += it.speed;
                    ctx.font = "30px Arial"; ctx.textAlign = "center"; ctx.fillText(it.icon, it.x + 15, it.y);
                    // Catch
                    if (it.y > 450 && it.y < 480 && it.x > basketX - 20 && it.x < basketX + 60) {
                        if (it.isBad) { endMinigame(false); return; }
                        else { stars++; items.splice(i, 1); if (stars >= 10) { endMinigame(true, 15); return; } }
                    } else if (it.y > 520) items.splice(i, 1);
                }
                mgAnim = requestAnimationFrame(loop);
            }
            loop();
            const handle = (clientX) => {
                const r = c.getBoundingClientRect();
                basketX = (clientX - r.left) * (c.width / r.width) - 30;
                if (basketX < 0) basketX = 0; if (basketX > 340) basketX = 340;
            };
            c.onmousemove = (e) => handle(e.clientX);
            c.ontouchmove = (e) => { e.preventDefault(); handle(e.touches[0].clientX); };
        }
    </script>
</body>

</html>